load "ozmansiksek.m";
load "quadPts.m";

ModCrvQuot:=function(N,wlist,remwlist)
C:=CuspForms(N);
ws:=[AtkinLehnerOperator(C,n) : n in wlist];
remws:=[AtkinLehnerOperator(C,n) : n in remwlist];
W:=AtkinLehnerOperator(C,N);
NN:=&meet([Nullspace(Matrix(w-1)) : w in ws] cat [Nullspace(1-W^2)]);
dim:=Dimension(NN);
seqs:=[[Coordinates(NN,Basis(NN)[i]*Matrix(w)) : i in [1..dim]] : w in remws];
BB:=[&+[(Integers()!(2*Eltseq(Basis(NN)[i])[j]))*C.j : j in [1..Dimension(C)]] : i in [1..dim]];
prec:=500;
L<q>:=LaurentSeriesRing(Rationals(),prec);
R<[x]>:=PolynomialRing(Rationals(),dim);
Bexp:=[L!qExpansion(BB[i],prec) : i in [1..dim]];
eqns:=[R | ];
	d:=1;
	tf:=false;
	while tf eq false do
		d:=d+1;
		mons:=MonomialsOfDegree(R,d);
		monsq:=[Evaluate(mon,Bexp) : mon in mons];
		V:=VectorSpace(Rationals(),#mons);
		W:=VectorSpace(Rationals(),prec-10);
		h:=hom<V->W | [W![Coefficient(monsq[i],j) : j in [1..(prec-10)]] : i in [1..#mons]]>;
		K:=Kernel(h);
		eqns:=eqns cat [ &+[Eltseq(V!k)[j]*mons[j] : j in [1..#mons] ] : k in Basis(K)  ];
        I:=Radical(ideal<R | eqns>);
		X:=Scheme(ProjectiveSpace(R),I);
		if Dimension(X) eq 1 then
			if IsSingular(X) eq false then
				X:=Curve(ProjectiveSpace(R),eqns);
				if Genus(X) eq dim then
					tf:=true;
				end if;
			end if;
		end if;
	end while;
	eqns:=GroebnerBasis(ideal<R | eqns>); // Simplifying the equations.
	tf:=true;
	repeat
		t:=#eqns;
		tf:=(eqns[t] in ideal<R | eqns[1..(t-1)]>);
		if tf then
			Exclude(~eqns,eqns[t]);
		end if;
	until tf eq false;
	t:=0;
	repeat
		t:=t+1;
		tf:=(eqns[t] in ideal<R | Exclude(eqns,eqns[t])>);
		if tf then
			Exclude(~eqns,eqns[t]);
			t:=0;
		end if;
	until tf eq false and t eq #eqns;
	X:=Curve(ProjectiveSpace(R),eqns); // Our model for X_0(N) discovered via the canonical embedding.
	assert Genus(X) eq dim;
	assert IsSingular(X) eq false;
    indexGam:=N*&*[Rationals() | 1+1/p : p in PrimeDivisors(N)];
	indexGam:=Integers()!indexGam; // Index of Gamma_0(N) in SL_2(Z)
	for eqn in eqns do
		eqnScaled:=LCM([Denominator(c) : c in Coefficients(eqn)])*eqn;
		wt:=2*Degree(eqn); // Weight of eqn as a cuspform.
		hecke:=Ceiling(indexGam*wt/12);  // Hecke=Sturm bound.
										// See Stein's book, Thm 9.18.
		Bexp1:=[qExpansion(BB[i],hecke+10) : i in [1..dim]]; // q-expansions
                        // of basis for S
                        // up to precision hecke+10.
		assert Valuation(Evaluate(eqnScaled,Bexp1)) gt hecke+1;
	end for; // We have now checked the correctness of the equations for X.
seqlist:=[[&+[seq[i][j]*x[j] : j in [1..dim]] : i in [1..dim]] : seq in seqs];
wmaplist:=[iso<X->X | seq,seq> : seq in seqlist];
return X,wmaplist,seqs;
end function;


quadPts2:=function(X,N,UB : vb:=true, mw:=[], search:=true); 
	// vb is a verbose flag.
	// If it is set to true it will print intermediate steps.
	// If search is set to true, the command will search
	// for additional degree 2 divisors using the command
	// searchDiv2 
	
	
	//X,Z,phi,jinvN,al,numdenom:=modeqns(N,n); // This command is from the file "modEqns.m";
	//if vb then
		//print "X_0(N) is the curve", X, "with genus", Genus(X);
	//end if; 
	 // X=X_0(N)
 	// Z=X_0(n)
	// and phi : X --> Z is the degeneracy map
	// jinvN is the j-function as an element of the function field of X. 
	//
	//
	// We construct the cusps on X_0(N)
	cusps:=[Place(a): a in Points(X:Bound:=100)];
	//if vb then
		//print "Thus cusps are these places", cusps;
	//end if;
	// Sanity check!
	//cuspDegrees:=[EulerPhi(GCD(m,N div m)) :  m in Divisors(N)];  // The cusp degrees as predicted by theory.
	//assert Sort(cuspDegrees) eq Sort([Degree(d) : d in cusps]); // The degrees of the cusps we have found agree with theory.
	cusps1:=[P : P in cusps];
	//assert #cusps1 ge 2; 
				// There are always at least two cusps 
				// of degree 1 corresponding to the
				// factors 1 and N of N.
	P0:=cusps1[1]; // This will our base for the Abel-Jacobi map.
	if vb then
		print "The base point for the Abel-Jacobi map is", P0;
	end if;
	deg2:=[cusps1[i]+cusps1[j] : i,j in [1..#cusps1] | i le j];
	// These are the degree 2 divisors we know from the cusps.
	if vb then
		print "There are", #deg2, "effective degree 2 divisors that are composed of rational points";
	end if;
	p0:=3;
	while IsDivisibleBy(N,p0) do
		p0:=NextPrime(p0);
	end while;
	// Now p0 will be an odd prime of good reduction for X_0(N).
	h,Ksub,bas,divs:=findGenerators(X,cusps,P0,p0);
	if mw ne [] then
		MW:=AbelianGroup(mw);
		assert IsIsomorphic(MW,Ksub);
		print "The given Mordell--Weil group is indeed isomorphic to
				the cuspidal subgroup.";
	end if; 
	if vb then
		print "The cuspidal group is isomorphic to", Ksub;
	end if;
	// Here Ksub is an abstract group isomorphic to the
	// subgroup of J(\Q) generated by [D-degree(D)*P0 : D in cusps] (i.e. the cuspidal subgroup).
	// divs is a subset of cusps that generates the same group.
	// h is the homomorphism \Z^r-->Ksub where r=#divs
	// and i-th standard basis vector is mapped to the image of
	// D-degree(D)*P0 where D=cusps[r].
	// bas is a subset of \Z^r which maps to a basis of Ksub
	// and is therefore (morally) a basis for the cuspidal  
	// subgroup of J(\Q).
	prs:=[p : p in PrimesInInterval(3,UB) | IsDivisibleBy(N,p) eq false];
	if mw eq [] then
		homs:=possibleJList(X,divs,P0,Ksub,bas,prs);
		// homs is a list of injective homomorphisms
		// with domain Ksub such that for one
		// of them the codomain is isomorphic to J(\Q).
		assert &and[Domain(h) eq Ksub : h in homs];
		assert &and[#Kernel(h) eq 1 : h in homs];
		quos:=[quo<Codomain(h) | Image(h)> : h in homs];
		if vb then
			print "The possibilities for J(Q)/C are", quos;
		end if;
		I:=LCM([Exponent(Q) : Q in quos]);  // I*J(\Q) belongs to the cuspidal.
	else
		quos:=[AbelianGroup([1])];
		I:=1;
	end if;
	if vb then
		print "I*J(Q) is contained in the cuspidal subgroup where I=", I;
	end if;
	if search then
		deg2New:=searchDiv2(X,1,false); // Searching for degree 2 effective divisors.
		deg2New:=[D : D in deg2New | D in deg2 eq false];
		if vb then
			if #deg2New gt 0 then
				print "A search found", #deg2New, "new effective degree 2 divisors.";
			end if;
		end if;
		deg2:=deg2 cat deg2New;
	end if;
	deg2New:=MWSieve(X,deg2,divs,P0,h,Ksub,bas,[p0],1);
	// Trying to find additional degree 2 divisors by sieve modulo p0.
	deg2New:=[D : D in deg2New | D in deg2 eq false];
	if vb then
		if #deg2New gt 0 then
			print "The Mordell--Weil sieve found", #deg2New, "new effective degree 2 divisors.";
		end if;
	end if;
	deg2:=deg2 cat deg2New;
	if vb then
		print "The following is a list of degree 2 effective divisors D
			such that [D-2P_0] belongs to the cuspidal subgroup";
		print deg2;
	end if;
	degtwoI:=MWSieve(X,deg2,divs,P0,h,Ksub,bas,prs,I);
	// This uses the Mordell--Weil sieve (with primes in prs) 
	// to return a set of effective divisors of degree 2*I 
	// such that if D is an effective degree 2 divisor not
	// in deg2 then I*D is linearly equivalent to some element of degtwoI.
	if #degtwoI eq 0 then
		print "succeeded in determining all effective divisors of degree 2";
		//pls:=[pr[1] : pr in &cat[Decomposition(D) : D in deg2]];
		//pls1:=SetToSequence(Set([D : D in pls | Degree(D) eq 1]));
		//pls2:=SetToSequence(Set([D : D in pls | Degree(D) eq 2]));
		//return X,jinvN,I,Ksub,S,cusps,deg2,degtwoI,pls1,pls2;
	else
		print "if D is an unknown effective divisor of degree 2 then I*D is equivalent to one of the list:", degtwoI;
		degtwoINew:=degtwoI;
		for i in [1..#degtwoI] do
			D:=degtwoI[i];
			assert IsEffective(D);
			assert Degree(D) eq 2*I;
			L,phi:=RiemannRochSpace(D);
			assert Dimension(L) ge 1; // As D is effective.
			if Dimension(L) eq 1 then
				print "For the", i, "-th divisor the RR space has dimension 1
								and we can simply divide by I";
				assert Divisor(phi(L.1)) eq D!0;
				decomp:=Decomposition(D);
				if &and [IsDivisibleBy(d[2],I) : d in decomp] then
					DoverI:=&+[(d[2] div I)*d[1] : d in decomp ];		 	
					if DoverI in deg2 eq false then
						Append(~deg2,DoverI);
					end if;
				end if;
				Exclude(~degtwoINew,D);
			else	//Dimension(L) at least 2.
				if Dimension(L) ge 3 then
					print "For the", i, "-th divisor the RR space 
							has dimension", Dimension(L);
					print "This case is not programmed yet.";
				else
					ID:=Ideal(D);
					B:=Basis(ID);
					Qalpha<alpha>:=FunctionField(Rationals());
					Xalpha:=ChangeRing(X,Qalpha);
					Ralpha:=CoordinateRing(AmbientSpace(Xalpha));
					IDalpha:=ideal< Ralpha | [Ralpha!f : f in B]>;	
					Dalpha:=Divisor(Xalpha,IDalpha);
					L,phi:=RiemannRochSpace(Dalpha);
					assert Dimension(L) eq 2;
					f1:=phi(L.1);
					f2:=phi(L.2);
					D1:=Dalpha+Divisor(f1+alpha*f2);
					decomp:=Decomposition(D1);
					assert #decomp eq 1;
					assert decomp[1,2] eq 1;
					Palpha:=decomp[1,1];
					assert Degree(Palpha) eq 2*I;
					Falpha:=ResidueClassField(Palpha);
					falpha:=MinimalPolynomial(Falpha.1);
					if Degree(falpha) lt 2*I then
						falpha:=Norm(falpha); // In this case the residue class field of Palpha
									// is an extension of an extension of Qalpha.
					end if;
					assert Degree(falpha) eq 2*I;
					disc:=PolynomialRing(Rationals())!Numerator(Discriminant(falpha)); 
					// This discriminant must vanish
					// at the values of alpha where D1 is I*divisor. 
					rts:=[r[1] : r in Roots(disc)];
					if  #rts gt 0 then // If there are no roots in \Q, then D1 is not
						// I*(effective divisor) for any (finite) value of alpha.
						for r in rts do
							E:=Dalpha+Divisor(f1+r*f2);
							assert &and[IsDivisibleBy(pr[2],I) : pr in Decomposition(E)] eq false;
							// Therefore E is not I*(effective divisor).
						end for;	
					end if;
					// We next have to do the same of alpha=infty (projectively speaking).
					E:=Dalpha+Divisor(f2);
					assert &and[IsDivisibleBy(pr[2],I) : pr in Decomposition(E)] eq false;
					// Therefore E is not I*(effective divisor).
					print "Succeeded in eliminating one of the divisors.";
					Exclude(~degtwoINew,D);	
				end if;
			end if;
		end for;		
		degtwoI:=degtwoINew;
		if #degtwoI eq 0 then
			print "Succeeded in determining all effective divisors of degree 2.";
		else
			print "There are still", #degtwoI, "divisors of degree", 2*I, "we cannot eliminate.";
		end if;
	end if;
	print "We know", #deg2, "effective degree 2 divisors";
	pls:=[pr[1] : pr in &cat[Decomposition(D) : D in deg2]];
	pls1:=SetToSequence(Set([D : D in pls | Degree(D) eq 1])); // Places of degree 1.
	pls2:=SetToSequence(Set([D : D in pls | Degree(D) eq 2])); // Places of degree 2.
	
		//pls2NonCusp:=[ P : P in pls2 | Valuation(jinvN,P) ge 0];
		//disclist:=discsQuadPlaces(pls2NonCusp);
	//for D in disclist do
		//print "Considering points defined over Q(sqrt(D)) where D=", D;
		//print pls, pls1, pls2;
		//print "+++++++++++++++++++++++++++++++++++";
	//end for;
	return X,I,Ksub,quos,cusps,deg2,degtwoI,pls1,pls2;
end function;	
















//This function computes J_X(F_p).
JacobianFp:=function(X)
CC,phii,psii:=ClassGroup(X); //Algorithm of Hess
Z:=FreeAbelianGroup(1);
degr:=hom<CC->Z | [ Degree(phii(a))*Z.1 : a in OrderedGenerators(CC)]>;
JFp:=Kernel(degr); // This is isomorphic to J_X(\F_p).
return JFp,phii,psii;
end function;

X,w7:=ModCrvQuot(91,[13],[7]);
quadPts2(X,119,10);